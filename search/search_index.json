{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>An API mocking workhorse </p> <p>Enabling a sane development lifecycle for microservice-oriented architectures and LLM-driven tool chains.</p> <p>Use mockstack for:</p> <ul> <li> <p>Development . Simulating HTTP-based interactions between a particular component you're developing or debugging locally and multiple other components it depends on during execution of a particular flow. You can create template-based mock responses, simulate creation of resources in a realistic way, as well as proxy to other services using a rich rules DSL. Full request and response metadata and payloads can be observed via OpenTelemetry integration.</p> </li> <li> <p>Integration Testing . Creating a consistent environment for running integration tests on a single component, using fixture responses.</p> </li> <li> <p>LLM-powered Workflows . Speeding up development and reducing per-token costs of LLM-based workflows and tools for use with frameworks such as LangChain, LangGraph and others. When developing LLM-driven execution graphs. Optional Ollama integration allows for realistic mocking of 3rd party LLMs without changing a line of code in your project. In addition, when you want to have a consistent response from a tool while you're tuning prompts or debugging other aspects of a particular trace you can create various fixture responses with varying levels of dynamic content that is template-driven. mockstack can give you a solid foundation for this.</p> </li> <li> <p>Chaos Engineering . mockstack can simulate various real-world runtime error scenarios such as timeouts, http error codes, and invalid response payloads. This can be a great way to do some upfront Chaos Monkey type of testing on software components.</p> </li> </ul> <p>Highlights include:</p> <ul> <li>Multiple strategies for handling requests such as Jinja template files with intelligent URL request-to-template routing, proxy strategy, and mixed strategies. </li> <li>Observability via OpenTelemetry integration. Get detailed traces of your sessions instantly reported to backends such as Grafana, Jaeger, Zipkin, etc. </li> <li>Configurability via pydantic-settings supports customizing behaviour via environment variables and a <code>.env</code> file. </li> <li>Comprehensive unit-tests, linting and formatting coverage as well as vulnerabilities and security scanning with full CI automation to ensure stability and a high-quality codebase for production-grade use. </li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Install using uv. This package conforms the concept of a tool and hence can simply install / run with uvx:</p> <pre><code>uvx mockstack --help\n</code></pre> <p>or install into a persistent environment and add it to the PATH with:</p> <pre><code>uv tool install mockstack\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<p>See the examples directory for complete examples with documentation.</p> <p>Available configuration options are here.</p> <p>Setting individual options can be done either through an <code>.env</code> file, individual environment variables, or command-line arguments.</p> <p>Minimal example to get you started:</p> <pre><code>    mkdir -p ~/mockstack-templates\n    echo '{\"message\": \"Hello from mockstack!\"}' &gt; ~/mockstack-templates/myservice-api-myresource.j2\n\n    export MOCKSTACK__TEMPLATES_DIR=~/mockstack-templates/\n    uvx mockstack\n</code></pre> <p>You can then hit <code>http://localhost:8000/myservice/api/myresource/23faa8cf-5daa-4bcb-8c92-27018b712aa9</code> (or any other UUID).</p> <p>This is of course just the tip of the iceberg.</p> <p>See also the included .env.example for more settings you are likely to find useful. You can copy that file to <code>.env</code> and fill in configuration as needed based on the given examples.</p> <p>Out of the box, you get the following behavior when using the default <code>filefixtures</code> strategy:</p> <ul> <li>The HTTP request <code>GET /someservice/api/v1/user/c27f5b2b-6e81-420d-a4e4-6426e1c32db8</code> will try to find <code>&lt;templates_dir&gt;/someservice-api-v1-user.c27f5b2b-6e81-420d-a4e4-6426e1c32db8.j2</code>,   and will fallback to <code>&lt;templates_dir&gt;/someservice-api-v1-user.j2</code> (and finally to <code>index.j2</code> if exists). These are j2 files that have access to request body context variables.</li> <li>The HTTP request <code>POST /someservice/api/v2/item</code> with a JSON body will attempt to intelligently simulate the creation of a resource, returning the appropriate status code and will echo back the provided request resource, after injecting additional metadata fields based on strategy configuration. This is useful for services that expect fields such as <code>id</code> and <code>created_at</code> on returned created resources.</li> <li>HTTP requests for <code>DELETE</code> / <code>PUT</code> / <code>PATCH</code> are a no-op by default, simply returning the appropriate status code.</li> <li>The HTTP request <code>POST /someservice/api/v2/embedding_search</code> will be handled as a search request rather than a resource creation, returning an appropriate http status code and mock results based on user-configurable formatting.</li> </ul> <p>Overall, the design philosophy is that things \"just work\". The framework attempts to intelligently deduce the intent of the request as much as possible and act accordingly, while leaving room for advanced users to go in and customize behavior using the configuration options.</p>"},{"location":"#testing","title":"Testing","text":"<p>Invoke unit-tests with:</p> <pre><code>uv run python -m pytest\n</code></pre> <p>Linting, formatting, static type checks etc. are all managed via pre-commit hooks. These will run automatically on every commit. You can invoke these manually on all files with:</p> <pre><code>pre-commit run --all-files\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>If you are contributing to development, you will want to clone this project, and can then install it locally with:</p> <pre><code>gh repo clone promptromp/mockstack\ncd mockstack/\nuv sync\nuv pip install -e .\n</code></pre> <p>Run in development mode (for live-reload of changes when developing):</p> <pre><code>uv run uvicorn --factory mockstack.main:create_app --reload\n</code></pre> <p>Note that when you run using the uvicorn CLI, you will need to set any configuration via <code>.env</code> file or environment variables.</p>"},{"location":"configuration/","title":"Configuration","text":"<p>mockstack can be configured through multiple methods, in order of priority:</p> <ul> <li>Command-line arguments</li> <li>Environment variables</li> <li><code>.env</code> file</li> </ul> <p>All configuration options are prefixed with <code>MOCKSTACK__</code> when using environment variables or the <code>.env</code> file.</p>"},{"location":"configuration/#general-settings","title":"General Settings","text":"Option Type Default Description <code>debug</code> boolean <code>false</code> Whether to run in debug mode <code>host</code> string <code>0.0.0.0</code> Host to run the server on <code>port</code> integer <code>8000</code> Port to run the server on <code>strategy</code> string <code>filefixtures</code> Strategy to use for handling requests. Options: <code>filefixtures</code>, <code>proxyrules</code>"},{"location":"configuration/#opentelemetry-settings","title":"OpenTelemetry Settings","text":"Option Type Default Description <code>opentelemetry.enabled</code> boolean <code>false</code> Whether to enable OpenTelemetry integration <code>opentelemetry.endpoint</code> string <code>http://localhost:4317/</code> OpenTelemetry endpoint <code>opentelemetry.capture_response_body</code> boolean <code>false</code> Whether to capture response body in traces"},{"location":"configuration/#strategy-specific-settings","title":"Strategy-Specific Settings","text":""},{"location":"configuration/#filefixtures-strategy","title":"FileFixtures Strategy","text":"Option Type Default Description <code>templates_dir</code> string - Base directory for templates used by the strategy <code>filefixtures_enable_templates_for_post</code> boolean <code>false</code> Whether to enable template-based responses for POST requests"},{"location":"configuration/#proxyrules-strategy","title":"ProxyRules Strategy","text":"Option Type Default Description <code>proxyrules_rules_filename</code> string - Rules filename for proxyrules strategy <code>proxyrules_redirect_via</code> string <code>reverse_proxy</code> Controls behavior of proxying. Options: <code>reverse_proxy</code>, <code>http_307_temporary</code>, <code>http_301_permanent</code> <code>proxyrules_reverse_proxy_timeout</code> float <code>10.0</code> Default timeout for reverse proxy requests in seconds <code>proxyrules_simulate_create_on_missing</code> boolean <code>false</code> Whether to simulate creation of resources when a POST request is made to a resource that doesn't match any rules"},{"location":"configuration/#resource-creation-settings","title":"Resource Creation Settings","text":"Option Type Default Description <code>created_resource_metadata</code> object See below Metadata fields to inject into created resources <code>missing_resource_fields</code> object See below Fields to inject into missing resources response JSON"},{"location":"configuration/#default-created_resource_metadata","title":"Default created_resource_metadata","text":"<pre><code>{\n    \"id\": \"{{ uuid4() }}\",\n    \"createdAt\": \"{{ utcnow().isoformat() }}\",\n    \"updatedAt\": \"{{ utcnow().isoformat() }}\",\n    \"createdBy\": \"{{ request.headers.get('X-User-Id', uuid4()) }}\",\n    \"status\": {\n        \"code\": \"OK\",\n        \"error_code\": null\n    }\n}\n</code></pre>"},{"location":"configuration/#default-missing_resource_fields","title":"Default missing_resource_fields","text":"<pre><code>{\n    \"code\": 404,\n    \"message\": \"mockstack: resource not found\",\n    \"retryable\": false\n}\n</code></pre>"},{"location":"configuration/#logging-configuration","title":"Logging Configuration","text":"<p>The logging configuration follows the Python logging configuration schema. By default, it includes:</p> <ul> <li>Rich console handler</li> <li>Uvicorn formatter</li> <li>Separate loggers for different components</li> <li>Debug level logging for strategy-specific loggers</li> </ul>"},{"location":"configuration/#example-configuration","title":"Example Configuration","text":"<p>Here's an example <code>.env</code> file:</p> <pre><code>MOCKSTACK__STRATEGY=filefixtures\nMOCKSTACK__TEMPLATES_DIR=~/mockstack-templates/\nMOCKSTACK__OPENTELEMETRY__ENABLED=true\nMOCKSTACK__OPENTELEMETRY__CAPTURE_RESPONSE_BODY=true\n</code></pre>"},{"location":"configuration/#command-line-usage","title":"Command Line Usage","text":"<p>You can also set configuration options via command line arguments:</p> <pre><code>uvx mockstack --strategy filefixtures --templates-dir ~/mockstack-templates/\n</code></pre>"},{"location":"ollama/","title":"Ollama Integration","text":"<p>Mockstack provides integration with Ollama, allowing you to use real LLM responses in your mock templates. This is particularly useful for development, debugging, and integration testing scenarios where you want to capture the non-deterministic nature of LLM responses.</p>"},{"location":"ollama/#prerequisites","title":"Prerequisites","text":"<p>To use the Ollama integration, you'll need:</p> <ol> <li> <p>Mockstack installed with the optional <code>llm</code> dependencies:    <pre><code>uv pip install mockstack[llm]\n</code></pre></p> </li> <li> <p>Ollama installed locally with at least one model (e.g., \"llama3.2\")</p> </li> </ol>"},{"location":"ollama/#basic-usage","title":"Basic Usage","text":"<p>The Ollama integration works by routing requests to a template file that uses the special <code>ollama</code> template function.</p> <ol> <li> <p>Configure your LLM client to hit an endpoint that maps to a template filepath calling the <code>ollama</code> method, e.g.:    <pre><code>from langchain_openai import ChatOpenAI\n\nllm = ChatOpenAI(\n    model=\"gpt-4o\",\n    base_url=\"http://localhost:8000/ollama/openai/v1\",\n    api_key=\"SOME_STRING_THAT_DOES_NOT_MATTER\",\n)\n</code></pre></p> </li> <li> <p>Make requests as you normally would:    <pre><code>messages = [\n    (\n        \"system\",\n        \"You are a helpful assistant that translates English to French. Translate the user sentence.\",\n    ),\n    (\"human\", \"mockstack is pretty cool. But LLMs are way cooler\"),\n]\nai_msg = llm.invoke(messages)\nprint(ai_msg.content)\n</code></pre></p> </li> </ol>"},{"location":"ollama/#integration-with-templates","title":"Integration with Templates","text":"<p>You can use Ollama responses within your Jinja templates via the provided <code>ollama</code> template function. This allows you to:</p> <ol> <li>Mix static and dynamic content</li> <li>Apply transformations to the LLM responses</li> <li>Create conditional logic based on the responses</li> </ol> <p>Example template structure:</p> <pre><code>{\n  \"id\": \"chatcmpl-123\",\n  \"object\": \"chat.completion\",\n  \"created\": 1677652288,\n  \"model\": \"gpt-4.1\",\n  \"choices\": [{\n    \"index\": 0,\n    \"message\": {\n      \"role\": \"assistant\",\n      \"content\": \"{{ ollama(request_json.messages, 'llama3.2') | json_escape }}\"\n    },\n    \"finish_reason\": \"stop\"\n  }],\n  \"usage\": {\n    \"prompt_tokens\": 9,\n    \"completion_tokens\": 12,\n    \"total_tokens\": 21\n  }\n}\n</code></pre>"},{"location":"ollama/#best-practices","title":"Best Practices","text":"<ol> <li>Caching: Consider implementing caching for frequently used responses to improve performance</li> <li>Model Selection: Choose the appropriate model based on your testing needs</li> <li>Error Handling: Implement proper error handling in your templates</li> <li>Performance: Be mindful of response times when using real LLM responses</li> </ol>"},{"location":"ollama/#limitations","title":"Limitations","text":"<ul> <li>The integration requires a local Ollama instance</li> <li>Response times will be slower than static templates</li> <li>Model availability depends on your local setup</li> </ul>"},{"location":"strategies/base/","title":"Base Strategy","text":"<p>The <code>BaseStrategy</code> class serves as the foundation for all mockstack strategies. It defines the core interface that all strategies must implement.</p>"},{"location":"strategies/base/#interface","title":"Interface","text":""},{"location":"strategies/base/#constructor","title":"Constructor","text":"<pre><code>def __init__(self, settings: Settings, *args, **kwargs)\n</code></pre> <p>Initializes the strategy with the provided settings.</p>"},{"location":"strategies/base/#methods","title":"Methods","text":""},{"location":"strategies/base/#apply","title":"<code>apply</code>","text":"<pre><code>async def apply(self, request: Request) -&gt; Response\n</code></pre> <p>This is the main method that all strategies must implement. It takes a FastAPI <code>Request</code> object and returns a FastAPI <code>Response</code> object. This is where the strategy's core logic for handling requests is implemented.</p>"},{"location":"strategies/base/#update_opentelemetry","title":"<code>update_opentelemetry</code>","text":"<pre><code>def update_opentelemetry(self, request: Request, *args, **kwargs) -&gt; None\n</code></pre> <p>This method allows strategies to add strategy-specific attributes to the OpenTelemetry span. The span is available on <code>request.state.span</code>. When OpenTelemetry is not enabled, this span will exist but will not be reported.</p>"},{"location":"strategies/base/#creating-custom-strategies","title":"Creating Custom Strategies","text":"<p>To create a custom strategy, you should:</p> <ol> <li>Inherit from <code>BaseStrategy</code></li> <li>Implement the <code>apply</code> method</li> <li>Optionally override <code>update_opentelemetry</code> to add strategy-specific telemetry</li> </ol> <p>Example:</p> <pre><code>from mockstack.strategies.base import BaseStrategy\nfrom fastapi import Request, Response\n\nclass CustomStrategy(BaseStrategy):\n    async def apply(self, request: Request) -&gt; Response:\n        # Implement your custom logic here\n        pass\n\n    def update_opentelemetry(self, request: Request, *args, **kwargs) -&gt; None:\n        # Add custom telemetry attributes\n        request.state.span.set_attribute(\"custom.attribute\", \"value\")\n</code></pre>"},{"location":"strategies/filefixtures/","title":"FileFixtures Strategy","text":"<p>The <code>FileFixturesStrategy</code> is a template-based strategy that uses Jinja2 templates to generate responses. It's particularly useful for creating consistent mock responses for your API endpoints.</p>"},{"location":"strategies/filefixtures/#overview","title":"Overview","text":"<p>This strategy:</p> <ul> <li>Uses Jinja2 templates stored in a specified directory</li> <li>Intelligently matches requests to templates based on the request path</li> <li>Supports all HTTP methods (GET, POST, PUT, PATCH, DELETE)</li> <li>Simulates resource creation for POST requests which are not handled by proxying rules (behavior controlled via configuration)</li> <li>Provides OpenTelemetry integration for observability</li> </ul>"},{"location":"strategies/filefixtures/#template-resolution","title":"Template Resolution","text":"<p>For a given request path like <code>/api/v1/projects/1234</code>, the strategy will look for templates in the following order:</p> <ol> <li><code>api-v1-projects.1234.j2</code> (specific to the resource ID)</li> <li><code>api-v1-projects.j2</code> (generic for the resource type)</li> <li><code>index.j2</code> (fallback template)</li> </ol>"},{"location":"strategies/filefixtures/#http-method-handling","title":"HTTP Method Handling","text":""},{"location":"strategies/filefixtures/#get-requests","title":"GET Requests","text":"<ul> <li>Attempts to find and render a matching template</li> <li>Returns 404 if no matching template is found</li> </ul>"},{"location":"strategies/filefixtures/#post-requests","title":"POST Requests","text":"<p>The strategy intelligently handles POST requests based on the request context:</p> <ol> <li>Search Requests: If the request looks like a search (based on URL and body), returns a template response</li> <li>Command Requests: If the request looks like a command, returns a 201 CREATED status with template response</li> <li>Resource Creation: Otherwise, simulates resource creation with injected metadata</li> </ol>"},{"location":"strategies/filefixtures/#deleteputpatch-requests","title":"DELETE/PUT/PATCH Requests","text":"<ul> <li>Returns 204 NO CONTENT by default</li> <li>These are no-op operations in the default implementation</li> </ul>"},{"location":"strategies/filefixtures/#template-context","title":"Template Context","text":"<p>Templates have access to the following context variables:</p> <ul> <li><code>request</code>: The FastAPI Request object</li> <li><code>request.body</code>: The parsed request body</li> <li><code>request.headers</code>: The request headers</li> <li><code>request.query_params</code>: The query parameters</li> <li><code>request.path_params</code>: The path parameters</li> </ul>"},{"location":"strategies/filefixtures/#resource-creation","title":"Resource Creation","text":"<p>When simulating resource creation (POST requests), the strategy injects the following metadata fields by default:</p> <pre><code>{\n    \"id\": \"{{ uuid4() }}\",\n    \"createdAt\": \"{{ utcnow().isoformat() }}\",\n    \"updatedAt\": \"{{ utcnow().isoformat() }}\",\n    \"createdBy\": \"{{ request.headers.get('X-User-Id', uuid4()) }}\",\n    \"status\": {\n        \"code\": \"OK\",\n        \"error_code\": null\n    }\n}\n</code></pre>"},{"location":"strategies/filefixtures/#configuration","title":"Configuration","text":"<p>The strategy requires the following configuration:</p> <pre><code>settings = Settings(\n    strategy=\"filefixtures\",\n    templates_dir=\"/path/to/templates\",\n    filefixtures_enable_templates_for_post=True  # Optional: Enables template-based responses for POST requests\n)\n</code></pre>"},{"location":"strategies/filefixtures/#example-template","title":"Example Template","text":"<p>Here's an example template for a user resource:</p> <pre><code>{\n    \"id\": \"{{ uuid4() }}\",\n    \"name\": \"{{ request.body.name }}\",\n    \"email\": \"{{ request.body.email }}\",\n    \"createdAt\": \"{{ utcnow().isoformat() }}\",\n    \"updatedAt\": \"{{ utcnow().isoformat() }}\"\n}\n</code></pre>"},{"location":"strategies/filefixtures/#opentelemetry-integration","title":"OpenTelemetry Integration","text":"<p>The strategy automatically adds the following OpenTelemetry attributes:</p> <ul> <li><code>mockstack.filefixtures.template_name</code>: The name of the template being rendered</li> </ul>"},{"location":"strategies/filefixtures/#error-handling","title":"Error Handling","text":"<p>When no matching template is found, the strategy returns a 404 response with the following structure:</p> <pre><code>{\n    \"code\": 404,\n    \"message\": \"mockstack: resource not found\",\n    \"retryable\": false\n}\n</code></pre>"},{"location":"strategies/proxyrules/","title":"ProxyRules Strategy","text":"<p>The <code>ProxyRulesStrategy</code> is a powerful strategy that allows you to define rules for redirecting or proxying requests to other services. It's particularly useful when you need to mix mock responses with real service calls.</p>"},{"location":"strategies/proxyrules/#overview","title":"Overview","text":"<p>This strategy:</p> <ul> <li>Uses a YAML configuration file to define routing rules</li> <li>Supports multiple redirection methods (HTTP redirects or reverse proxy)</li> <li>Can simulate resource creation for unmatched requests</li> <li>Provides OpenTelemetry integration for observability</li> </ul>"},{"location":"strategies/proxyrules/#configuration","title":"Configuration","text":"<p>The strategy requires the following configuration:</p> <pre><code>settings = Settings(\n    strategy=\"proxyrules\",\n    proxyrules_rules_filename=\"/path/to/rules.yaml\",\n    proxyrules_redirect_via=\"REVERSE_PROXY\",  # or \"HTTP_TEMPORARY_REDIRECT\" or \"HTTP_PERMANENT_REDIRECT\"\n    proxyrules_reverse_proxy_timeout=10.0,\n    proxyrules_simulate_create_on_missing=False\n)\n</code></pre>"},{"location":"strategies/proxyrules/#rules-configuration","title":"Rules Configuration","text":"<p>Rules are defined in a YAML file with the following structure:</p> <pre><code>rules:\n  - name: \"user-service\"\n    pattern: \"^/api/v1/users/(.*)\"\n    replacement: \"http://user-service/api/v1/users/\\1\"\n    method: \"GET\"  # optional, if not specified matches all methods\n</code></pre>"},{"location":"strategies/proxyrules/#rule-properties","title":"Rule Properties","text":"<ul> <li><code>name</code>: Optional identifier for the rule (used in telemetry)</li> <li><code>pattern</code>: Regular expression pattern to match against the request path</li> <li><code>replacement</code>: URL template to redirect to (can use capture groups from pattern)</li> <li><code>method</code>: Optional HTTP method to match (if not specified, matches all methods)</li> </ul>"},{"location":"strategies/proxyrules/#redirection-methods","title":"Redirection Methods","text":"<p>The strategy supports three redirection methods:</p> <ol> <li> <p>HTTP Temporary Redirect (307)</p> <ul> <li>Client makes a new request to the target URL</li> <li>Preserves the original HTTP method</li> </ul> </li> <li> <p>HTTP Permanent Redirect (301)</p> <ul> <li>Client makes a new request to the target URL</li> <li>Browsers may cache the redirect</li> </ul> </li> <li> <p>Reverse Proxy</p> <ul> <li>Server forwards the request to the target service</li> <li>Client is unaware of the redirection</li> <li>Useful when you need to work with clients that do not handle HTTP redirects gracefully.</li> </ul> </li> </ol>"},{"location":"strategies/proxyrules/#resource-creation-simulation","title":"Resource Creation Simulation","text":"<p>When <code>proxyrules_simulate_create_on_missing</code> is enabled and a POST request doesn't match any rules, the strategy will simulate resource creation by:</p> <ol> <li>Injecting metadata fields into the response</li> <li>Returning a 201 CREATED status code</li> <li>Echoing back the request body with added metadata</li> </ol> <p>The default metadata fields are controlled via the configuration file and at the time of writing are as follows:</p> <pre><code>{\n    \"id\": \"{{ uuid4() }}\",\n    \"createdAt\": \"{{ utcnow().isoformat() }}\",\n    \"updatedAt\": \"{{ utcnow().isoformat() }}\",\n    \"createdBy\": \"{{ request.headers.get('X-User-Id', uuid4()) }}\",\n    \"status\": {\n        \"code\": \"OK\",\n        \"error_code\": null\n    }\n}\n</code></pre>"},{"location":"strategies/proxyrules/#opentelemetry-integration","title":"OpenTelemetry Integration","text":"<p>The strategy automatically adds the following OpenTelemetry attributes:</p> <ul> <li><code>mockstack.proxyrules.rule_name</code>: The name of the matched rule (if specified)</li> <li><code>mockstack.proxyrules.rule_method</code>: The HTTP method the rule matches (if specified)</li> <li><code>mockstack.proxyrules.rule_pattern</code>: The pattern used to match the request</li> <li><code>mockstack.proxyrules.rule_replacement</code>: The replacement URL template</li> <li><code>mockstack.proxyrules.rewritten_url</code>: The final URL after applying the rule</li> </ul>"},{"location":"strategies/proxyrules/#example-rules","title":"Example Rules","text":"<p>Here are some example rules:</p> <pre><code>rules:\n  # Redirect all GET requests to /api/v1/users/* to the user service\n  - name: \"user-service-get\"\n    pattern: \"^/api/v1/users/(.*)\"\n    replacement: \"http://user-service/api/v1/users/\\1\"\n    method: \"GET\"\n\n  # Proxy all POST requests to /api/v1/orders to the order service\n  - name: \"order-service-post\"\n    pattern: \"^/api/v1/orders\"\n    replacement: \"http://order-service/api/v1/orders\"\n    method: \"POST\"\n\n  # Redirect all requests to /api/v1/products to the product service\n  - name: \"product-service\"\n    pattern: \"^/api/v1/products/(.*)\"\n    replacement: \"http://product-service/api/v1/products/\\1\"\n</code></pre>"},{"location":"strategies/proxyrules/#error-handling","title":"Error Handling","text":"<p>When no matching rule is found and resource creation simulation is disabled, the strategy returns a 404 NOT FOUND response.</p>"}]}